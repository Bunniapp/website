"use strict";(self.webpackChunktimeless_frontend=self.webpackChunktimeless_frontend||[]).push([[8291],{68291:($n,Ft,xt)=>{xt.r(Ft),xt.d(Ft,{encodeToCurve:()=>Vn,hashToCurve:()=>Cn,schnorr:()=>Hn,secp256k1:()=>yt});var Ut={};function Ht(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`Wrong positive integer: ${t}`)}function te(t,...e){if(!(t instanceof Uint8Array))throw new Error("Expected Uint8Array");if(e.length>0&&!e.includes(t.length))throw new Error(`Expected Uint8Array of length ${e}, not of length=${t.length}`)}xt.r(Ut),xt.d(Ut,{bitGet:()=>Xe,bitLen:()=>We,bitMask:()=>jt,bitSet:()=>Qe,bytesToHex:()=>at,bytesToNumberBE:()=>V,bytesToNumberLE:()=>Zt,concatBytes:()=>Z,createHmacDrbg:()=>ae,ensureBytes:()=>C,equalBytes:()=>Me,hexToBytes:()=>ut,hexToNumber:()=>$t,numberToBytesBE:()=>Q,numberToBytesLE:()=>ce,numberToHexUnpadded:()=>ie,numberToVarBytesBE:()=>Ye,utf8ToBytes:()=>St,validateObject:()=>lt});const it={number:Ht,bool:function(t){if("boolean"!=typeof t)throw new Error(`Expected boolean, not ${t}`)},bytes:te,hash:function(t){if("function"!=typeof t||"function"!=typeof t.create)throw new Error("Hash should be wrapped by utils.wrapConstructor");Ht(t.outputLen),Ht(t.blockLen)},exists:function(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")},output:function(t,e){te(t);const n=e.outputLen;if(t.length<n)throw new Error(`digestInto() expects output buffer of length at least ${n}`)}},kt="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0,Rt=t=>t instanceof Uint8Array,Ct=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),Y=(t,e)=>t<<32-e|t>>>e;if(68!==new Uint8Array(new Uint32Array([287454020]).buffer)[0])throw new Error("Non little-endian hardware is not supported");function gt(t){if("string"==typeof t&&(t=function(t){if("string"!=typeof t)throw new Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array((new TextEncoder).encode(t))}(t)),!Rt(t))throw new Error("expected Uint8Array, got "+typeof t);return t}Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));class ee{clone(){return this._cloneInto()}}function ne(t){const e=r=>t().update(gt(r)).digest(),n=t();return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=()=>t(),e}function re(t=32){if(kt&&"function"==typeof kt.getRandomValues)return kt.getRandomValues(new Uint8Array(t));throw new Error("crypto.getRandomValues must be defined")}class Ze extends ee{constructor(e,n,r,o){super(),this.blockLen=e,this.outputLen=n,this.padOffset=r,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=Ct(this.buffer)}update(e){it.exists(this);const{view:n,buffer:r,blockLen:o}=this,s=(e=gt(e)).length;for(let f=0;f<s;){const i=Math.min(o-this.pos,s-f);if(i!==o)r.set(e.subarray(f,f+i),this.pos),this.pos+=i,f+=i,this.pos===o&&(this.process(n,0),this.pos=0);else{const c=Ct(e);for(;o<=s-f;f+=o)this.process(c,f)}}return this.length+=e.length,this.roundClean(),this}digestInto(e){it.exists(this),it.output(e,this),this.finished=!0;const{buffer:n,view:r,blockLen:o,isLE:s}=this;let{pos:f}=this;n[f++]=128,this.buffer.subarray(f).fill(0),this.padOffset>o-f&&(this.process(r,0),f=0);for(let u=f;u<o;u++)n[u]=0;(function(t,e,n,r){if("function"==typeof t.setBigUint64)return t.setBigUint64(e,n,r);const o=BigInt(32),s=BigInt(4294967295),f=Number(n>>o&s),i=Number(n&s),a=r?0:4;t.setUint32(e+(r?4:0),f,r),t.setUint32(e+a,i,r)})(r,o-8,BigInt(8*this.length),s),this.process(r,0);const i=Ct(e),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const a=c/4,d=this.get();if(a>d.length)throw new Error("_sha2: outputLen bigger than state");for(let u=0;u<a;u++)i.setUint32(4*u,d[u],s)}digest(){const{buffer:e,outputLen:n}=this;this.digestInto(e);const r=e.slice(0,n);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:n,buffer:r,length:o,finished:s,destroyed:f,pos:i}=this;return e.length=o,e.pos=i,e.finished=s,e.destroyed=f,o%n&&e.buffer.set(r),e}}const je=(t,e,n)=>t&e^~t&n,Pe=(t,e,n)=>t&e^t&n^e&n,De=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),W=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),X=new Uint32Array(64);class oe extends Ze{constructor(){super(64,32,8,!1),this.A=0|W[0],this.B=0|W[1],this.C=0|W[2],this.D=0|W[3],this.E=0|W[4],this.F=0|W[5],this.G=0|W[6],this.H=0|W[7]}get(){const{A:e,B:n,C:r,D:o,E:s,F:f,G:i,H:c}=this;return[e,n,r,o,s,f,i,c]}set(e,n,r,o,s,f,i,c){this.A=0|e,this.B=0|n,this.C=0|r,this.D=0|o,this.E=0|s,this.F=0|f,this.G=0|i,this.H=0|c}process(e,n){for(let u=0;u<16;u++,n+=4)X[u]=e.getUint32(n,!1);for(let u=16;u<64;u++){const v=X[u-15],E=X[u-2],m=Y(v,7)^Y(v,18)^v>>>3,l=Y(E,17)^Y(E,19)^E>>>10;X[u]=l+X[u-7]+m+X[u-16]|0}let{A:r,B:o,C:s,D:f,E:i,F:c,G:a,H:d}=this;for(let u=0;u<64;u++){const E=d+(Y(i,6)^Y(i,11)^Y(i,25))+je(i,c,a)+De[u]+X[u]|0,l=(Y(r,2)^Y(r,13)^Y(r,22))+Pe(r,o,s)|0;d=a,a=c,c=i,i=f+E|0,f=s,s=o,o=r,r=E+l|0}r=r+this.A|0,o=o+this.B|0,s=s+this.C|0,f=f+this.D|0,i=i+this.E|0,c=c+this.F|0,a=a+this.G|0,d=d+this.H|0,this.set(r,o,s,f,i,c,a,d)}roundClean(){X.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}class ze extends oe{constructor(){super(),this.A=-1056596264,this.B=914150663,this.C=812702999,this.D=-150054599,this.E=-4191439,this.F=1750603025,this.G=1694076839,this.H=-1090891868,this.outputLen=28}}const Et=ne(()=>new oe),se=(ne(()=>new ze),BigInt(0)),Bt=BigInt(1),Ge=BigInt(2),vt=t=>t instanceof Uint8Array,Ke=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function at(t){if(!vt(t))throw new Error("Uint8Array expected");let e="";for(let n=0;n<t.length;n++)e+=Ke[t[n]];return e}function ie(t){const e=t.toString(16);return 1&e.length?`0${e}`:e}function $t(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);return BigInt(""===t?"0":`0x${t}`)}function ut(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);const e=t.length;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const n=new Uint8Array(e/2);for(let r=0;r<n.length;r++){const o=2*r,s=t.slice(o,o+2),f=Number.parseInt(s,16);if(Number.isNaN(f)||f<0)throw new Error("Invalid byte sequence");n[r]=f}return n}function V(t){return $t(at(t))}function Zt(t){if(!vt(t))throw new Error("Uint8Array expected");return $t(at(Uint8Array.from(t).reverse()))}function Q(t,e){return ut(t.toString(16).padStart(2*e,"0"))}function ce(t,e){return Q(t,e).reverse()}function Ye(t){return ut(ie(t))}function C(t,e,n){let r;if("string"==typeof e)try{r=ut(e)}catch(s){throw new Error(`${t} must be valid hex string, got "${e}". Cause: ${s}`)}else{if(!vt(e))throw new Error(`${t} must be hex string or Uint8Array`);r=Uint8Array.from(e)}const o=r.length;if("number"==typeof n&&o!==n)throw new Error(`${t} expected ${n} bytes, got ${o}`);return r}function Z(...t){const e=new Uint8Array(t.reduce((r,o)=>r+o.length,0));let n=0;return t.forEach(r=>{if(!vt(r))throw new Error("Uint8Array expected");e.set(r,n),n+=r.length}),e}function Me(t,e){if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function St(t){if("string"!=typeof t)throw new Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array((new TextEncoder).encode(t))}function We(t){let e;for(e=0;t>se;t>>=Bt,e+=1);return e}function Xe(t,e){return t>>BigInt(e)&Bt}const Qe=(t,e,n)=>t|(n?Bt:se)<<BigInt(e),jt=t=>(Ge<<BigInt(t-1))-Bt,Pt=t=>new Uint8Array(t),fe=t=>Uint8Array.from(t);function ae(t,e,n){if("number"!=typeof t||t<2)throw new Error("hashLen must be a number");if("number"!=typeof e||e<2)throw new Error("qByteLen must be a number");if("function"!=typeof n)throw new Error("hmacFn must be a function");let r=Pt(t),o=Pt(t),s=0;const f=()=>{r.fill(1),o.fill(0),s=0},i=(...u)=>n(o,r,...u),c=(u=Pt())=>{o=i(fe([0]),u),r=i(),0!==u.length&&(o=i(fe([1]),u),r=i())},a=()=>{if(s++>=1e3)throw new Error("drbg: tried 1000 values");let u=0;const v=[];for(;u<e;){r=i();const E=r.slice();v.push(E),u+=r.length}return Z(...v)};return(u,v)=>{let E;for(f(),c(u);!(E=v(a()));)c();return f(),E}}const Je={bigint:t=>"bigint"==typeof t,function:t=>"function"==typeof t,boolean:t=>"boolean"==typeof t,string:t=>"string"==typeof t,isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>"function"==typeof t&&Number.isSafeInteger(t.outputLen)};function lt(t,e,n={}){const r=(o,s,f)=>{const i=Je[s];if("function"!=typeof i)throw new Error(`Invalid validator "${s}", expected function`);const c=t[o];if(!(f&&void 0===c||i(c,t)))throw new Error(`Invalid param ${String(o)}=${c} (${typeof c}), expected ${s}`)};for(const[o,s]of Object.entries(e))r(o,s,!1);for(const[o,s]of Object.entries(n))r(o,s,!0);return t}const H=BigInt(0),N=BigInt(1),J=BigInt(2),Fe=BigInt(3),Dt=BigInt(4),ue=BigInt(5),le=BigInt(8);function k(t,e){const n=t%e;return n>=H?n:e+n}function nn(t,e,n){if(n<=H||e<H)throw new Error("Expected power/modulo > 0");if(n===N)return H;let r=N;for(;e>H;)e&N&&(r=r*t%n),t=t*t%n,e>>=N;return r}function G(t,e,n){let r=t;for(;e-- >H;)r*=r,r%=n;return r}function At(t,e){if(t===H||e<=H)throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);let n=k(t,e),r=e,o=H,s=N,f=N,i=H;for(;n!==H;){const a=r/n,d=r%n,u=o-f*a,v=s-i*a;r=n,n=d,o=f,s=i,f=u,i=v}if(r!==N)throw new Error("invert: does not exist");return k(o,e)}BigInt(9),BigInt(16);const sn=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function de(t){return lt(t,sn.reduce((r,o)=>(r[o]="function",r),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"}))}function zt(t,e){const n=void 0!==e?e:t.toString(2).length;return{nBitLength:n,nByteLength:Math.ceil(n/8)}}const ln=BigInt(0),Gt=BigInt(1);function he(t){return de(t.Fp),lt(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...zt(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}const{bytesToNumberBE:wn,hexToBytes:gn}=Ut,ct={Err:class extends Error{constructor(e=""){super(e)}},_parseInt(t){const{Err:e}=ct;if(t.length<2||2!==t[0])throw new e("Invalid signature integer tag");const n=t[1],r=t.subarray(2,n+2);if(!n||r.length!==n)throw new e("Invalid signature integer: wrong length");if(128&r[0])throw new e("Invalid signature integer: negative");if(0===r[0]&&!(128&r[1]))throw new e("Invalid signature integer: unnecessary leading zero");return{d:wn(r),l:t.subarray(n+2)}},toSig(t){const{Err:e}=ct,n="string"==typeof t?gn(t):t;if(!(n instanceof Uint8Array))throw new Error("ui8a expected");let r=n.length;if(r<2||48!=n[0])throw new e("Invalid signature tag");if(n[1]!==r-2)throw new e("Invalid signature: incorrect length");const{d:o,l:s}=ct._parseInt(n.subarray(2)),{d:f,l:i}=ct._parseInt(s);if(i.length)throw new e("Invalid signature: left bytes after parsing");return{r:o,s:f}},hexFromSig(t){const e=a=>8&Number.parseInt(a[0],16)?"00"+a:a,n=a=>{const d=a.toString(16);return 1&d.length?`0${d}`:d},r=e(n(t.s)),o=e(n(t.r)),s=r.length/2,f=o.length/2,i=n(s),c=n(f);return`30${n(f+s+4)}02${c}${o}02${i}${r}`}},K=BigInt(0),U=BigInt(1),F=BigInt(2),It=BigInt(3),we=BigInt(4);function mn(t){const e=function(t){const e=he(t);return lt(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}(t),{Fp:n,n:r}=e,o=n.BYTES+1,s=2*n.BYTES+1;function i(g){return k(g,r)}function c(g){return At(g,r)}const{ProjectivePoint:a,normPrivateKeyToScalar:d,weierstrassEquation:u,isWithinCurveOrder:v}=function(t){const e=function(t){const e=he(t);lt(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:n,Fp:r,a:o}=e;if(n){if(!r.eql(o,r.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if("object"!=typeof n||"bigint"!=typeof n.beta||"function"!=typeof n.splitScalar)throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...e})}(t),{Fp:n}=e,r=e.toBytes||((m,l,w)=>{const h=l.toAffine();return Z(Uint8Array.from([4]),n.toBytes(h.x),n.toBytes(h.y))}),o=e.fromBytes||(m=>{const l=m.subarray(1);return{x:n.fromBytes(l.subarray(0,n.BYTES)),y:n.fromBytes(l.subarray(n.BYTES,2*n.BYTES))}});function s(m){const{a:l,b:w}=e,h=n.sqr(m),b=n.mul(h,m);return n.add(n.add(b,n.mul(m,l)),w)}if(!n.eql(n.sqr(e.Gy),s(e.Gx)))throw new Error("bad generator point: equation left != right");function f(m){return"bigint"==typeof m&&K<m&&m<e.n}function i(m){if(!f(m))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function c(m){const{allowedPrivateKeyLengths:l,nByteLength:w,wrapPrivateKey:h,n:b}=e;if(l&&"bigint"!=typeof m){if(m instanceof Uint8Array&&(m=at(m)),"string"!=typeof m||!l.includes(m.length))throw new Error("Invalid key");m=m.padStart(2*w,"0")}let p;try{p="bigint"==typeof m?m:V(C("private key",m,w))}catch{throw new Error(`private key must be ${w} bytes, hex or bigint, not ${typeof m}`)}return h&&(p=k(p,b)),i(p),p}const a=new Map;function d(m){if(!(m instanceof u))throw new Error("ProjectivePoint expected")}class u{constructor(l,w,h){if(this.px=l,this.py=w,this.pz=h,null==l||!n.isValid(l))throw new Error("x required");if(null==w||!n.isValid(w))throw new Error("y required");if(null==h||!n.isValid(h))throw new Error("z required")}static fromAffine(l){const{x:w,y:h}=l||{};if(!l||!n.isValid(w)||!n.isValid(h))throw new Error("invalid affine point");if(l instanceof u)throw new Error("projective point not allowed");const b=p=>n.eql(p,n.ZERO);return b(w)&&b(h)?u.ZERO:new u(w,h,n.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(l){const w=n.invertBatch(l.map(h=>h.pz));return l.map((h,b)=>h.toAffine(w[b])).map(u.fromAffine)}static fromHex(l){const w=u.fromAffine(o(C("pointHex",l)));return w.assertValidity(),w}static fromPrivateKey(l){return u.BASE.multiply(c(l))}_setWindowSize(l){this._WINDOW_SIZE=l,a.delete(this)}assertValidity(){if(this.is0()){if(e.allowInfinityPoint)return;throw new Error("bad point: ZERO")}const{x:l,y:w}=this.toAffine();if(!n.isValid(l)||!n.isValid(w))throw new Error("bad point: x or y not FE");const h=n.sqr(w),b=s(l);if(!n.eql(h,b))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:l}=this.toAffine();if(n.isOdd)return!n.isOdd(l);throw new Error("Field doesn't support isOdd")}equals(l){d(l);const{px:w,py:h,pz:b}=this,{px:p,py:S,pz:I}=l,x=n.eql(n.mul(w,I),n.mul(p,b)),B=n.eql(n.mul(h,I),n.mul(S,b));return x&&B}negate(){return new u(this.px,n.neg(this.py),this.pz)}double(){const{a:l,b:w}=e,h=n.mul(w,It),{px:b,py:p,pz:S}=this;let I=n.ZERO,x=n.ZERO,B=n.ZERO,A=n.mul(b,b),$=n.mul(p,p),L=n.mul(S,S),_=n.mul(b,p);return _=n.add(_,_),B=n.mul(b,S),B=n.add(B,B),I=n.mul(l,B),x=n.mul(h,L),x=n.add(I,x),I=n.sub($,x),x=n.add($,x),x=n.mul(I,x),I=n.mul(_,I),B=n.mul(h,B),L=n.mul(l,L),_=n.sub(A,L),_=n.mul(l,_),_=n.add(_,B),B=n.add(A,A),A=n.add(B,A),A=n.add(A,L),A=n.mul(A,_),x=n.add(x,A),L=n.mul(p,S),L=n.add(L,L),A=n.mul(L,_),I=n.sub(I,A),B=n.mul(L,$),B=n.add(B,B),B=n.add(B,B),new u(I,x,B)}add(l){d(l);const{px:w,py:h,pz:b}=this,{px:p,py:S,pz:I}=l;let x=n.ZERO,B=n.ZERO,A=n.ZERO;const $=e.a,L=n.mul(e.b,It);let _=n.mul(w,p),j=n.mul(h,S),P=n.mul(b,I),nt=n.add(w,h),g=n.add(p,S);nt=n.mul(nt,g),g=n.add(_,j),nt=n.sub(nt,g),g=n.add(w,b);let y=n.add(p,I);return g=n.mul(g,y),y=n.add(_,P),g=n.sub(g,y),y=n.add(h,b),x=n.add(S,I),y=n.mul(y,x),x=n.add(j,P),y=n.sub(y,x),A=n.mul($,g),x=n.mul(L,P),A=n.add(x,A),x=n.sub(j,A),A=n.add(j,A),B=n.mul(x,A),j=n.add(_,_),j=n.add(j,_),P=n.mul($,P),g=n.mul(L,g),j=n.add(j,P),P=n.sub(_,P),P=n.mul($,P),g=n.add(g,P),_=n.mul(j,g),B=n.add(B,_),_=n.mul(y,g),x=n.mul(nt,x),x=n.sub(x,_),_=n.mul(nt,j),A=n.mul(y,A),A=n.add(A,_),new u(x,B,A)}subtract(l){return this.add(l.negate())}is0(){return this.equals(u.ZERO)}wNAF(l){return E.wNAFCached(this,a,l,w=>{const h=n.invertBatch(w.map(b=>b.pz));return w.map((b,p)=>b.toAffine(h[p])).map(u.fromAffine)})}multiplyUnsafe(l){const w=u.ZERO;if(l===K)return w;if(i(l),l===U)return this;const{endo:h}=e;if(!h)return E.unsafeLadder(this,l);let{k1neg:b,k1:p,k2neg:S,k2:I}=h.splitScalar(l),x=w,B=w,A=this;for(;p>K||I>K;)p&U&&(x=x.add(A)),I&U&&(B=B.add(A)),A=A.double(),p>>=U,I>>=U;return b&&(x=x.negate()),S&&(B=B.negate()),B=new u(n.mul(B.px,h.beta),B.py,B.pz),x.add(B)}multiply(l){i(l);let h,b,w=l;const{endo:p}=e;if(p){const{k1neg:S,k1:I,k2neg:x,k2:B}=p.splitScalar(w);let{p:A,f:$}=this.wNAF(I),{p:L,f:_}=this.wNAF(B);A=E.constTimeNegate(S,A),L=E.constTimeNegate(x,L),L=new u(n.mul(L.px,p.beta),L.py,L.pz),h=A.add(L),b=$.add(_)}else{const{p:S,f:I}=this.wNAF(w);h=S,b=I}return u.normalizeZ([h,b])[0]}multiplyAndAddUnsafe(l,w,h){const b=u.BASE,p=(I,x)=>x!==K&&x!==U&&I.equals(b)?I.multiply(x):I.multiplyUnsafe(x),S=p(this,w).add(p(l,h));return S.is0()?void 0:S}toAffine(l){const{px:w,py:h,pz:b}=this,p=this.is0();null==l&&(l=p?n.ONE:n.inv(b));const S=n.mul(w,l),I=n.mul(h,l),x=n.mul(b,l);if(p)return{x:n.ZERO,y:n.ZERO};if(!n.eql(x,n.ONE))throw new Error("invZ was invalid");return{x:S,y:I}}isTorsionFree(){const{h:l,isTorsionFree:w}=e;if(l===U)return!0;if(w)return w(u,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:l,clearCofactor:w}=e;return l===U?this:w?w(u,this):this.multiplyUnsafe(e.h)}toRawBytes(l=!0){return this.assertValidity(),r(u,this,l)}toHex(l=!0){return at(this.toRawBytes(l))}}u.BASE=new u(e.Gx,e.Gy,n.ONE),u.ZERO=new u(n.ZERO,n.ONE,n.ZERO);const v=e.nBitLength,E=function(t,e){const n=(o,s)=>{const f=s.negate();return o?f:s},r=o=>({windows:Math.ceil(e/o)+1,windowSize:2**(o-1)});return{constTimeNegate:n,unsafeLadder(o,s){let f=t.ZERO,i=o;for(;s>ln;)s&Gt&&(f=f.add(i)),i=i.double(),s>>=Gt;return f},precomputeWindow(o,s){const{windows:f,windowSize:i}=r(s),c=[];let a=o,d=a;for(let u=0;u<f;u++){d=a,c.push(d);for(let v=1;v<i;v++)d=d.add(a),c.push(d);a=d.double()}return c},wNAF(o,s,f){const{windows:i,windowSize:c}=r(o);let a=t.ZERO,d=t.BASE;const u=BigInt(2**o-1),v=2**o,E=BigInt(o);for(let m=0;m<i;m++){const l=m*c;let w=Number(f&u);f>>=E,w>c&&(w-=v,f+=Gt);const h=l,b=l+Math.abs(w)-1,p=m%2!=0,S=w<0;0===w?d=d.add(n(p,s[h])):a=a.add(n(S,s[b]))}return{p:a,f:d}},wNAFCached(o,s,f,i){const c=o._WINDOW_SIZE||1;let a=s.get(o);return a||(a=this.precomputeWindow(o,c),1!==c&&s.set(o,i(a))),this.wNAF(c,a,f)}}}(u,e.endo?Math.ceil(v/2):v);return{CURVE:e,ProjectivePoint:u,normPrivateKeyToScalar:c,weierstrassEquation:s,isWithinCurveOrder:f}}({...e,toBytes(g,y,O){const q=y.toAffine(),T=n.toBytes(q.x),R=Z;return O?R(Uint8Array.from([y.hasEvenY()?2:3]),T):R(Uint8Array.from([4]),T,n.toBytes(q.y))},fromBytes(g){const y=g.length,O=g[0],q=g.subarray(1);if(y!==o||2!==O&&3!==O){if(y===s&&4===O)return{x:n.fromBytes(q.subarray(0,n.BYTES)),y:n.fromBytes(q.subarray(n.BYTES,2*n.BYTES))};throw new Error(`Point of length ${y} was invalid. Expected ${o} compressed bytes or ${s} uncompressed bytes`)}{const T=V(q);if(!function(g){return K<g&&g<n.ORDER}(T))throw new Error("Point is not on curve");const R=u(T);let D=n.sqrt(R);return 1==(1&O)!=((D&U)===U)&&(D=n.neg(D)),{x:T,y:D}}}}),E=g=>at(Q(g,e.nByteLength));function m(g){return g>r>>U}const w=(g,y,O)=>V(g.slice(y,O));class h{constructor(y,O,q){this.r=y,this.s=O,this.recovery=q,this.assertValidity()}static fromCompact(y){const O=e.nByteLength;return y=C("compactSignature",y,2*O),new h(w(y,0,O),w(y,O,2*O))}static fromDER(y){const{r:O,s:q}=ct.toSig(C("DER",y));return new h(O,q)}assertValidity(){if(!v(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!v(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(y){return new h(this.r,this.s,y)}recoverPublicKey(y){const{r:O,s:q,recovery:T}=this,R=B(C("msgHash",y));if(null==T||![0,1,2,3].includes(T))throw new Error("recovery id invalid");const D=2===T||3===T?O+e.n:O;if(D>=n.ORDER)throw new Error("recovery id 2 or 3 invalid");const rt=a.fromHex((0==(1&T)?"02":"03")+E(D)),ot=c(D),dt=i(-R*ot),pt=i(q*ot),st=a.BASE.multiplyAndAddUnsafe(rt,dt,pt);if(!st)throw new Error("point at infinify");return st.assertValidity(),st}hasHighS(){return m(this.s)}normalizeS(){return this.hasHighS()?new h(this.r,i(-this.s),this.recovery):this}toDERRawBytes(){return ut(this.toDERHex())}toDERHex(){return ct.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return ut(this.toCompactHex())}toCompactHex(){return E(this.r)+E(this.s)}}const b={isValidPrivateKey(g){try{return d(g),!0}catch{return!1}},normPrivateKeyToScalar:d,randomPrivateKey:()=>{const y=function(t,e,n=!1){const r=(t=C("privateHash",t)).length,o=zt(e).nByteLength+8;if(o<24||r<o||r>1024)throw new Error(`hashToPrivateScalar: expected ${o}-1024 bytes of input, got ${r}`);return k(n?Zt(t):V(t),e-N)+N}(e.randomBytes(n.BYTES+8),r);return Q(y,e.nByteLength)},precompute:(g=8,y=a.BASE)=>(y._setWindowSize(g),y.multiply(BigInt(3)),y)};function S(g){const y=g instanceof Uint8Array,O="string"==typeof g,q=(y||O)&&g.length;return y?q===o||q===s:O?q===2*o||q===2*s:g instanceof a}const x=e.bits2int||function(g){const y=V(g),O=8*g.length-e.nBitLength;return O>0?y>>BigInt(O):y},B=e.bits2int_modN||function(g){return i(x(g))},A=jt(e.nBitLength);function $(g){if("bigint"!=typeof g)throw new Error("bigint expected");if(!(K<=g&&g<A))throw new Error(`bigint expected < 2^${e.nBitLength}`);return Q(g,e.nByteLength)}const _={lowS:e.lowS,prehash:!1},j={lowS:e.lowS,prehash:!1};return a.BASE._setWindowSize(8),{CURVE:e,getPublicKey:function(g,y=!0){return a.fromPrivateKey(g).toRawBytes(y)},getSharedSecret:function(g,y,O=!0){if(S(g))throw new Error("first arg must be private key");if(!S(y))throw new Error("second arg must be public key");return a.fromHex(y).multiply(d(g)).toRawBytes(O)},sign:function(g,y,O=_){const{seed:q,k2sig:T}=function(g,y,O=_){if(["recovered","canonical"].some(ft=>ft in O))throw new Error("sign() legacy options not supported");const{hash:q,randomBytes:T}=e;let{lowS:R,prehash:D,extraEntropy:z}=O;null==R&&(R=!0),g=C("msgHash",g),D&&(g=C("prehashed msgHash",q(g)));const rt=B(g),ot=d(y),dt=[$(ot),$(rt)];if(null!=z){const ft=!0===z?T(n.BYTES):z;dt.push(C("extraEntropy",ft,n.BYTES))}const pt=Z(...dt),st=rt;return{seed:pt,k2sig:function(ft){const ht=x(ft);if(!v(ht))return;const Oe=c(ht),M=a.BASE.multiply(ht).toAffine(),wt=i(M.x);if(wt===K)return;const Lt=i(Oe*i(st+wt*ot));if(Lt===K)return;let _e=(M.x===wt?0:2)|Number(M.y&U),Te=Lt;return R&&m(Lt)&&(Te=function(g){return m(g)?i(-g):g}(Lt),_e^=1),new h(wt,Te,_e)}}}(g,y,O);return ae(e.hash.outputLen,e.nByteLength,e.hmac)(q,T)},verify:function(g,y,O,q=j){const T=g;if(y=C("msgHash",y),O=C("publicKey",O),"strict"in q)throw new Error("options.strict was renamed to lowS");const{lowS:R,prehash:D}=q;let z,rt;try{if("string"==typeof T||T instanceof Uint8Array)try{z=h.fromDER(T)}catch(M){if(!(M instanceof ct.Err))throw M;z=h.fromCompact(T)}else{if("object"!=typeof T||"bigint"!=typeof T.r||"bigint"!=typeof T.s)throw new Error("PARSE");{const{r:M,s:wt}=T;z=new h(M,wt)}}rt=a.fromHex(O)}catch(M){if("PARSE"===M.message)throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(R&&z.hasHighS())return!1;D&&(y=e.hash(y));const{r:ot,s:dt}=z,pt=B(y),st=c(dt),Jt=i(pt*st),ft=i(ot*st),ht=a.BASE.multiplyAndAddUnsafe(rt,Jt,ft)?.toAffine();return!!ht&&i(ht.x)===ot},ProjectivePoint:a,Signature:h,utils:b}}const Bn=V;function tt(t,e){if(t<0||t>=1<<8*e)throw new Error(`bad I2OSP call: value=${t} length=${e}`);const n=Array.from({length:e}).fill(0);for(let r=e-1;r>=0;r--)n[r]=255&t,t>>>=8;return new Uint8Array(n)}function vn(t,e){const n=new Uint8Array(t.length);for(let r=0;r<t.length;r++)n[r]=t[r]^e[r];return n}function bt(t){if(!(t instanceof Uint8Array))throw new Error("Uint8Array expected")}function Kt(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function ge(t,e,n){lt(n,{DST:"string",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});const{p:r,k:o,m:s,hash:f,expand:i,DST:c}=n;bt(t),Kt(e);const a=function(t){if(t instanceof Uint8Array)return t;if("string"==typeof t)return St(t);throw new Error("DST must be Uint8Array or string")}(c),d=r.toString(2).length,u=Math.ceil((d+o)/8),v=e*s*u;let E;if("xmd"===i)E=function(t,e,n,r){bt(t),bt(e),Kt(n),e.length>255&&(e=r(Z(St("H2C-OVERSIZE-DST-"),e)));const{outputLen:o,blockLen:s}=r,f=Math.ceil(n/o);if(f>255)throw new Error("Invalid xmd length");const i=Z(e,tt(e.length,1)),c=tt(0,s),a=tt(n,2),d=new Array(f),u=r(Z(c,t,a,tt(0,1),i));d[0]=r(Z(u,tt(1,1),i));for(let E=1;E<=f;E++){const m=[vn(u,d[E-1]),tt(E+1,1),i];d[E]=r(Z(...m))}return Z(...d).slice(0,n)}(t,a,v,f);else if("xof"===i)E=function(t,e,n,r,o){if(bt(t),bt(e),Kt(n),e.length>255){const s=Math.ceil(2*r/8);e=o.create({dkLen:s}).update(St("H2C-OVERSIZE-DST-")).update(e).digest()}if(n>65535||e.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return o.create({dkLen:n}).update(t).update(tt(n,2)).update(e).update(tt(e.length,1)).digest()}(t,a,v,o,f);else{if("_internal_pass"!==i)throw new Error('expand must be "xmd" or "xof"');E=t}const m=new Array(e);for(let l=0;l<e;l++){const w=new Array(s);for(let h=0;h<s;h++){const b=u*(h+l*s),p=E.subarray(b,b+u);w[h]=k(Bn(p),r)}m[l]=w}return m}class be extends ee{constructor(e,n){super(),this.finished=!1,this.destroyed=!1,it.hash(e);const r=gt(n);if(this.iHash=e.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,s=new Uint8Array(o);s.set(r.length>o?e.create().update(r).digest():r);for(let f=0;f<s.length;f++)s[f]^=54;this.iHash.update(s),this.oHash=e.create();for(let f=0;f<s.length;f++)s[f]^=106;this.oHash.update(s),s.fill(0)}update(e){return it.exists(this),this.iHash.update(e),this}digestInto(e){it.exists(this),it.bytes(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:n,iHash:r,finished:o,destroyed:s,blockLen:f,outputLen:i}=this;return e.finished=o,e.destroyed=s,e.blockLen=f,e.outputLen=i,e.oHash=n._cloneInto(e.oHash),e.iHash=r._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const ye=(t,e,n)=>new be(t,e).update(n).digest();function _n(t){return{hash:t,hmac:(e,...n)=>ye(t,e,function(...t){const e=new Uint8Array(t.reduce((r,o)=>r+o.length,0));let n=0;return t.forEach(r=>{if(!Rt(r))throw new Error("Uint8Array expected");e.set(r,n),n+=r.length}),e}(...n)),randomBytes:re}}ye.create=(t,e)=>new be(t,e);const Ot=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),_t=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),me=BigInt(1),Tt=BigInt(2),pe=(t,e)=>(t+e/Tt)/e;function xe(t){const e=Ot,n=BigInt(3),r=BigInt(6),o=BigInt(11),s=BigInt(22),f=BigInt(23),i=BigInt(44),c=BigInt(88),a=t*t*t%e,d=a*a*t%e,u=G(d,n,e)*d%e,v=G(u,n,e)*d%e,E=G(v,Tt,e)*a%e,m=G(E,o,e)*E%e,l=G(m,s,e)*m%e,w=G(l,i,e)*l%e,h=G(w,c,e)*w%e,b=G(h,i,e)*l%e,p=G(b,n,e)*d%e,S=G(p,f,e)*m%e,I=G(S,r,e)*a%e,x=G(I,Tt,e);if(!et.eql(et.sqr(x),t))throw new Error("Cannot find square root");return x}const et=function(t,e,n=!1,r={}){if(t<=H)throw new Error(`Expected Fp ORDER > 0, got ${t}`);const{nBitLength:o,nByteLength:s}=zt(t,e);if(s>2048)throw new Error("Field lengths over 2048 bytes are not supported");const f=function(t){if(t%Dt===Fe){const e=(t+N)/Dt;return function(r,o){const s=r.pow(o,e);if(!r.eql(r.sqr(s),o))throw new Error("Cannot find square root");return s}}if(t%le===ue){const e=(t-ue)/le;return function(r,o){const s=r.mul(o,J),f=r.pow(s,e),i=r.mul(o,f),c=r.mul(r.mul(i,J),f),a=r.mul(i,r.sub(c,r.ONE));if(!r.eql(r.sqr(a),o))throw new Error("Cannot find square root");return a}}return function(t){const e=(t-N)/J;let n,r,o;for(n=t-N,r=0;n%J===H;n/=J,r++);for(o=J;o<t&&nn(o,e,t)!==t-N;o++);if(1===r){const f=(t+N)/Dt;return function(c,a){const d=c.pow(a,f);if(!c.eql(c.sqr(d),a))throw new Error("Cannot find square root");return d}}const s=(n+N)/J;return function(i,c){if(i.pow(c,e)===i.neg(i.ONE))throw new Error("Cannot find square root");let a=r,d=i.pow(i.mul(i.ONE,o),n),u=i.pow(c,s),v=i.pow(c,n);for(;!i.eql(v,i.ONE);){if(i.eql(v,i.ZERO))return i.ZERO;let E=1;for(let l=i.sqr(v);E<a&&!i.eql(l,i.ONE);E++)l=i.sqr(l);const m=i.pow(d,N<<BigInt(a-E-1));d=i.sqr(m),u=i.mul(u,m),v=i.mul(v,d),a=E}return u}}(t)}(t),i=Object.freeze({ORDER:t,BITS:o,BYTES:s,MASK:jt(o),ZERO:H,ONE:N,create:c=>k(c,t),isValid:c=>{if("bigint"!=typeof c)throw new Error("Invalid field element: expected bigint, got "+typeof c);return H<=c&&c<t},is0:c=>c===H,isOdd:c=>(c&N)===N,neg:c=>k(-c,t),eql:(c,a)=>c===a,sqr:c=>k(c*c,t),add:(c,a)=>k(c+a,t),sub:(c,a)=>k(c-a,t),mul:(c,a)=>k(c*a,t),pow:(c,a)=>function(t,e,n){if(n<H)throw new Error("Expected power > 0");if(n===H)return t.ONE;if(n===N)return e;let r=t.ONE,o=e;for(;n>H;)n&N&&(r=t.mul(r,o)),o=t.sqr(o),n>>=N;return r}(i,c,a),div:(c,a)=>k(c*At(a,t),t),sqrN:c=>c*c,addN:(c,a)=>c+a,subN:(c,a)=>c-a,mulN:(c,a)=>c*a,inv:c=>At(c,t),sqrt:r.sqrt||(c=>f(i,c)),invertBatch:c=>function(t,e){const n=new Array(e.length),r=e.reduce((s,f,i)=>t.is0(f)?s:(n[i]=s,t.mul(s,f)),t.ONE),o=t.inv(r);return e.reduceRight((s,f,i)=>t.is0(f)?s:(n[i]=t.mul(s,n[i]),t.mul(s,f)),o),n}(i,c),cmov:(c,a,d)=>d?a:c,toBytes:c=>n?ce(c,s):Q(c,s),fromBytes:c=>{if(c.length!==s)throw new Error(`Fp.fromBytes: expected ${s}, got ${c.length}`);return n?Zt(c):V(c)}});return Object.freeze(i)}(Ot,void 0,void 0,{sqrt:xe}),yt=function(t,e){const n=r=>mn({...t,..._n(r)});return Object.freeze({...n(e),create:n})}({a:BigInt(0),b:BigInt(7),Fp:et,n:_t,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const e=_t,n=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-me*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=n,f=BigInt("0x100000000000000000000000000000000"),i=pe(s*t,e),c=pe(-r*t,e);let a=k(t-i*n-c*o,e),d=k(-i*r-c*s,e);const u=a>f,v=d>f;if(u&&(a=e-a),v&&(d=e-d),a>f||d>f)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:u,k1:a,k2neg:v,k2:d}}}},Et),Nt=BigInt(0),Ee=t=>"bigint"==typeof t&&Nt<t&&t<Ot,Be={};function qt(t,...e){let n=Be[t];if(void 0===n){const r=Et(Uint8Array.from(t,o=>o.charCodeAt(0)));n=Z(r,r),Be[t]=n}return Et(Z(n,...e))}const Yt=t=>t.toRawBytes(!0).slice(1),Mt=t=>Q(t,32),Wt=t=>k(t,Ot),mt=t=>k(t,_t),Xt=yt.ProjectivePoint;function Qt(t){let e=yt.utils.normPrivateKeyToScalar(t),n=Xt.fromPrivateKey(e);return{scalar:n.hasEvenY()?e:mt(-e),bytes:Yt(n)}}function ve(t){if(!Ee(t))throw new Error("bad x: need 0 < x < p");const e=Wt(t*t);let r=xe(Wt(e*t+BigInt(7)));r%Tt!==Nt&&(r=Wt(-r));const o=new Xt(t,r,me);return o.assertValidity(),o}function Se(...t){return mt(V(qt("BIP0340/challenge",...t)))}function Ln(t){return Qt(t).bytes}function Un(t,e,n=re(32)){const r=C("message",t),{bytes:o,scalar:s}=Qt(e),f=C("auxRand",n,32),i=Mt(s^V(qt("BIP0340/aux",f))),c=qt("BIP0340/nonce",i,o,r),a=mt(V(c));if(a===Nt)throw new Error("sign failed: k is zero");const{bytes:d,scalar:u}=Qt(a),v=Se(d,o,r),E=new Uint8Array(64);if(E.set(d,0),E.set(Mt(mt(u+v*s)),32),!Ae(E,r,o))throw new Error("sign: Invalid signature produced");return E}function Ae(t,e,n){const r=C("signature",t,64),o=C("message",e),s=C("publicKey",n,32);try{const f=ve(V(s)),i=V(r.subarray(0,32));if(!Ee(i))return!1;const c=V(r.subarray(32,64));if(!(t=>"bigint"==typeof t&&Nt<t&&t<_t)(c))return!1;const a=Se(Mt(i),Yt(f),o),d=((t,e,n)=>Xt.BASE.multiplyAndAddUnsafe(t,e,n))(f,c,mt(-a));return!(!d||!d.hasEvenY()||d.toAffine().x!==i)}catch{return!1}}const Hn=(()=>({getPublicKey:Ln,sign:Un,verify:Ae,utils:{randomPrivateKey:yt.utils.randomPrivateKey,lift_x:ve,pointToBytes:Yt,numberToBytesBE:Q,bytesToNumberBE:V,taggedHash:qt,mod:k}}))(),kn=(()=>function(t,e){const n=e.map(r=>Array.from(r).reverse());return(r,o)=>{const[s,f,i,c]=n.map(a=>a.reduce((d,u)=>t.add(t.mul(d,r),u)));return r=t.div(s,f),o=t.mul(o,t.div(i,c)),{x:r,y:o}}}(et,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map(t=>t.map(e=>BigInt(e)))))(),Rn=(()=>function(t,e){if(de(t),!t.isValid(e.A)||!t.isValid(e.B)||!t.isValid(e.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");const n=function(t,e){const n=t.ORDER;let r=K;for(let m=n-U;m%F===K;m/=F)r+=U;const o=r,s=F<<o-U-U,f=s*F,i=(n-U)/f,c=(i-U)/F,a=f-U,d=s,u=t.pow(e,i),v=t.pow(e,(i+U)/F);let E=(m,l)=>{let w=u,h=t.pow(l,a),b=t.sqr(h);b=t.mul(b,l);let p=t.mul(m,b);p=t.pow(p,c),p=t.mul(p,h),h=t.mul(p,l),b=t.mul(p,m);let S=t.mul(b,h);p=t.pow(S,d);let I=t.eql(p,t.ONE);h=t.mul(b,v),p=t.mul(S,w),b=t.cmov(h,b,I),S=t.cmov(p,S,I);for(let x=o;x>U;x--){let B=x-F;B=F<<B-U;let A=t.pow(S,B);const $=t.eql(A,t.ONE);h=t.mul(b,w),w=t.mul(w,w),A=t.mul(S,w),b=t.cmov(h,b,$),S=t.cmov(A,S,$)}return{isValid:I,value:b}};if(t.ORDER%we===It){const m=(t.ORDER-It)/we,l=t.sqrt(t.neg(e));E=(w,h)=>{let b=t.sqr(h);const p=t.mul(w,h);b=t.mul(b,p);let S=t.pow(b,m);S=t.mul(S,p);const I=t.mul(S,l),x=t.mul(t.sqr(S),h),B=t.eql(x,w);return{isValid:B,value:t.cmov(I,S,B)}}}return E}(t,e.Z);if(!t.isOdd)throw new Error("Fp.isOdd is not implemented!");return r=>{let o,s,f,i,c,a,d,u;o=t.sqr(r),o=t.mul(o,e.Z),s=t.sqr(o),s=t.add(s,o),f=t.add(s,t.ONE),f=t.mul(f,e.B),i=t.cmov(e.Z,t.neg(s),!t.eql(s,t.ZERO)),i=t.mul(i,e.A),s=t.sqr(f),a=t.sqr(i),c=t.mul(a,e.A),s=t.add(s,c),s=t.mul(s,f),a=t.mul(a,i),c=t.mul(a,e.B),s=t.add(s,c),d=t.mul(o,f);const{isValid:v,value:E}=n(s,a);u=t.mul(o,r),u=t.mul(u,E),d=t.cmov(d,f,v),u=t.cmov(u,E,v);const m=t.isOdd(r)===t.isOdd(u);return u=t.cmov(t.neg(u),u,m),d=t.div(d,i),{x:d,y:u}}}(et,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:et.create(BigInt("-11"))}))(),Ie=(()=>{return t=yt.ProjectivePoint,e=t=>{const{x:e,y:n}=Rn(et.create(t[0]));return kn(e,n)},n={DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:et.ORDER,m:1,k:128,expand:"xmd",hash:Et},{hashToCurve(r,o){const s=ge(r,2,{...n,DST:n.DST,...o}),f=t.fromAffine(e(s[0])),i=t.fromAffine(e(s[1])),c=f.add(i).clearCofactor();return c.assertValidity(),c},encodeToCurve(r,o){const s=ge(r,1,{...n,DST:n.encodeDST,...o}),f=t.fromAffine(e(s[0])).clearCofactor();return f.assertValidity(),f}};var t,e,n})(),Cn=(()=>Ie.hashToCurve)(),Vn=(()=>Ie.encodeToCurve)()}}]);